#include "basicIO.h"
#include <thread>

// Simple cellular network simulator for Question 1
// Uses only the provided `basicIO` for input/output.

// Minimal template utility (to satisfy assignment requirement)
template<typename T>
T minT(T a, T b) {
    return a < b ? a : b;
}

class Device {
public:
    int id;
    int type; // 1 = voice, 2 = data, 3 = both
    int messages; // messages generated per connection
    int frequencyIndex; // 1-based frequency assigned

    Device(int i, int t, int m) : id(i), type(t), messages(m), frequencyIndex(-1) {}
};

class CellTower {
public:
    int frequencies; // number of frequency channels
    int maxUsersPerFrequency; // capacity per frequency

    CellTower(int freqs, int per) : frequencies(freqs), maxUsersPerFrequency(per) {}

    int capacity() const {
        return frequencies * maxUsersPerFrequency;
    }

    // assign devices round-robin to frequencies (1..frequencies)
    void assignDevices(Device** devices, int n) const {
        if (frequencies <= 0) return;
        for (int i = 0; i < n; ++i) {
            devices[i]->frequencyIndex = (i % frequencies) + 1;
        }
    }
};

class CellularCore {
public:
    int overheadPer100; // overhead messages per 100 messages
    int capacityMessages; // core's total message handling capacity

    CellularCore(int overhead, int capacity) : overheadPer100(overhead), capacityMessages(capacity) {}

    // compute effective messages after overhead
    int effectiveMessages(int messages) const {
        int extra = (messages / 100) * overheadPer100;
        return messages + extra;
    }

    // return how many devices (starting from index 0) can be supported
    int maxDevicesSupported(Device** devices, int n) const {
        int totalRaw = 0;
        for (int i = 0; i < n; ++i) {
            // add device messages
            totalRaw += devices[i]->messages;
            int eff = effectiveMessages(totalRaw);
            if (eff > capacityMessages) {
                return i; // previous devices only
            }
        }
        return n; // all supported
    }
};

// global object from basicIO
extern basicIO io;

int main() {
    try {
        io.activateInput();

        io.outputstring("Question 1: Cellular Simulation Framework\n");

        io.outputstring("Enter number of devices to simulate: ");
        int n = io.inputint();
        if (n <= 0) throw "Number of devices must be positive";

        // Allocate devices
        Device** devices = new Device*[n];

        for (int i = 0; i < n; ++i) {
            io.outputstring("\nDevice "); io.outputint(i+1); io.outputstring(" details:\n");

            io.outputstring(" Enter device id (int): ");
            int id = io.inputint();

            io.outputstring(" Enter type (1=voice,2=data,3=both): ");
            int type = io.inputint();
            if (type < 1 || type > 3) type = 2;

            io.outputstring(" Enter messages generated per connection (int): ");
            int msgs = io.inputint();
            if (msgs < 0) msgs = 0;

            devices[i] = new Device(id, type, msgs);
        }

        io.outputstring("\nEnter number of frequency channels in a single cell tower: ");
        int freq = io.inputint();
        if (freq <= 0) throw "Frequencies must be positive";

        io.outputstring("Enter max users allowed per frequency (tower policy): ");
        int perFreq = io.inputint();
        if (perFreq <= 0) throw "Users per frequency must be positive";

        CellTower tower(freq, perFreq);
        tower.assignDevices(devices, n);

        io.outputstring("\nEnter core overhead per 100 messages (int): ");
        int overhead = io.inputint();
        if (overhead < 0) overhead = 0;

        io.outputstring("Enter cellular core message capacity (total messages it can handle): ");
        int coreCap = io.inputint();
        if (coreCap < 0) coreCap = 0;

        CellularCore core(overhead, coreCap);

        // compute totals
        int totalRaw = 0;
        for (int i = 0; i < n; ++i) totalRaw += devices[i]->messages;
        int totalEffective = core.effectiveMessages(totalRaw);

        int supportedByCore = core.maxDevicesSupported(devices, n);
        int supportedByTower = minT(tower.capacity(), n);
        int finalSupported = minT(supportedByCore, supportedByTower);

        io.outputstring("\n--- Results ---\n");
        io.outputstring("Total raw messages generated by all devices: "); io.outputint(totalRaw); io.terminate();
        io.outputstring("Total effective messages after core overhead: "); io.outputint(totalEffective); io.terminate();
        io.outputstring("Cell tower total capacity (users): "); io.outputint(tower.capacity()); io.terminate();
        io.outputstring("Number of devices supported by core (in insertion order): "); io.outputint(supportedByCore); io.terminate();
        io.outputstring("Number of devices accommodated by tower (max allowed by frequencies): "); io.outputint(supportedByTower); io.terminate();
        io.outputstring("Final number of devices that can be active simultaneously: "); io.outputint(finalSupported); io.terminate();

        io.outputstring("\nEnter a frequency index to list occupying user ids (1-based): ");
        int whichFreq = io.inputint();
        if (whichFreq < 1 || whichFreq > freq) {
            io.outputstring("Invalid frequency index. Exiting.\n");
        } else {
            io.outputstring("Users on frequency "); io.outputint(whichFreq); io.outputstring(": ");
            int shown = 0;
            for (int i = 0; i < n; ++i) {
                if (devices[i]->frequencyIndex == whichFreq) {
                    // only show up to per-frequency capacity
                    if (shown < perFreq) {
                        io.outputint(devices[i]->id); io.outputstring(" ");
                        ++shown;
                    }
                }
            }
            io.terminate();
            if (shown == 0) {
                io.outputstring("(none)\n");
            }
        }

        // cleanup
        for (int i = 0; i < n; ++i) delete devices[i];
        delete [] devices;

    } catch (const char* e) {
        io.errorstring("Error: "); io.errorstring(e); io.terminate();
        return 1;
    } catch (...) {
        io.errorstring("Unknown error occurred\n");
        return 2;
    }

    return 0;
}
